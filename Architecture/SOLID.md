# SOLID-принципы
Это принципы проектирования архитекруры систем

- [Single responsibility](#single)
- [Open-closed](#open)
- [Liskov substitution](#liskov)
- [Interface segregation](#interface)
- [Dependency inversion](#dependency)

### <a name="single"></a> Single responsibility — принцип единственной ответственности
+ **Модуль должен отвечать за одного и только за одного актора.**
+ Принцип декларирует, что каждый объект должен иметь *одну обязанность* и эта обязанность должна быть *полностью инкапсулирована в класс*, а все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.
Следование принципу заключается обычно в декомпозиции сложных классов, которые делают сразу много вещей, на простые, отвественность которых очень специализирована. Но также и объединении в отдельный класс однотипной функциональности, которая может оказаться распределённой по многим классам, может рассматриваться как следование этому принципу.
SRP требует сознательного и осмысленного применения. Чрезмерная декомпозиция может оказаться и вредной, если она приводит к большей сложности или усложняет сопровождение.

### <a name="open"></a> Open-closed — принцип открытости / закрытости
+ **Программные сущности должны быть открыты для расширения и закрыты для изменения.**
+ Если одно изменение в программе влечет за собой каскад изменений в зависимых модулях, то в программе проявляются нежелательные признаки «плохого» дизайна.
Программа становится хрупкой, негибкой, непредсказуемой и непереиспользуемой. Принцип открытости-закрытости решает эти проблемы очень прямолинейным путем. **Он говорит, что необходимо проектировать модули, которые никогда не меняются.** Когда требования меняются, нужно расширять поведение таких модулей путем добавления нового кода, а не изменением старого, уже работающего кода.
+ Принцип открытости/закрытости — одна из движущих сил в архитектуре систем. Его цель — сделать систему легко расширяемой и обезопасить ее от влияния изменений. Эта цель достигается делением системы на компоненты и упорядочением их зависимостей в иерархию, защищающую компоненты уровнем выше от изменений в компонентах уровнем ниже.

### <a name="liskov"></a> Liskov substitution — принцип подстановки Барбары Лисков


### <a name="interface"></a> Interface segregation — принцип разделения интерфейса


### <a name="dependency"></a> Dependency inversion — принцип инверсии зависимостей
