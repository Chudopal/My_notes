# SOLID-принципы
Это принципы проектирования архитекруры систем

- [Single responsibility](#single)
- [Open-closed](#open)
- [Liskov substitution](#liskov)
- [Interface segregation](#interface)
- [Dependency inversion](#dependency)

### <a name="single"></a> Single responsibility — принцип единственной ответственности
+ **Модуль должен отвечать за одного и только за одного актора.**
+ Принцип декларирует, что каждый объект должен иметь *одну обязанность* и эта обязанность должна быть *полностью инкапсулирована в класс*, а *все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.*
Следование принципу заключается обычно в *декомпозиции* сложных классов, которые делают сразу много вещей, на простые, отвественность которых очень специализирована. Но также и объединении в отдельный класс однотипной функциональности, которая может оказаться распределённой по многим классам, может рассматриваться как следование этому принципу.
SRP требует сознательного и осмысленного применения. Чрезмерная декомпозиция может оказаться и вредной, если она приводит к большей сложности или усложняет сопровождение.

### <a name="open"></a> Open-closed — принцип открытости / закрытости
+ **Программные сущности должны быть открыты для расширения и закрыты для изменения.**
+ Если одно изменение в программе влечет за собой каскад изменений в зависимых модулях, то в программе проявляются нежелательные признаки «плохого» дизайна.
Программа становится хрупкой, негибкой, непредсказуемой и непереиспользуемой. Принцип открытости-закрытости решает эти проблемы очень прямолинейным путем. **Он говорит, что необходимо проектировать модули, которые никогда не меняются.** Когда требования меняются, нужно расширять поведение таких модулей путем добавления нового кода, а не изменением старого, уже работающего кода.
+ Принцип открытости/закрытости — одна из движущих сил в архитектуре систем. Его цель — **сделать систему легко расширяемой и обезопасить ее от влияния изменений.** Эта цель достигается *делением системы на компоненты* и *упорядочением их зависимостей в иерархию*, защищающую компоненты уровнем выше от изменений в компонентах уровнем ниже.

### <a name="liskov"></a> Liskov substitution — принцип подстановки Барбары Лисков
+ **Наследующий класс должен дополнять, а не замещать поведение базового класса.**
+ *Если для каждого объекта o1 типа S существует такой объект o2 типа T, что для всех программ P, определенных в терминах T, поведение P не изменяется при подстановке o1 вместо o2, то S является подтипом T1*
+ Если у нас есть класс A (не виртуальный, а вполне реально используемый в коде) и отнаследованный от него класс B, то если мы заменим все использования класса A на B, ничего не должно измениться в работе программы. Ведь класс B всего лишь расширяет функционал класса A.

### <a name="interface"></a> Interface segregation — принцип разделения интерфейса


### <a name="dependency"></a> Dependency inversion — принцип инверсии зависимостей
+ **Наиболее гибкими получаются системы, в которых зависимости в исходном коде направлены на абстракции, а не на конкретные реализации.**
   + Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций.
   + **Абстракции не должны зависеть от деталей.** Детали должны зависеть от абстракций.
+ Стабильными называются такие архитектуры, в которых вместо зависимостей от переменчивых конкретных реализаций используются зависимости от стабильных абстрактных интерфейсов. Это сводится к набору очень простых правил:
   + *Не ссылайтесь на изменчивые конкретные классы.* Ссылайтесь на абстрактные интерфейсы. Это правило применимо во всех языках, независимо от устройства системы типов. Оно также накладывает важные ограничения на создание объектов и определяет преимущественное использование шаблона «Абстрактная фабрика».
   + *Не наследуйте изменчивые конкретные классы.* Это естественное следствие из предыдущего правила, но оно достойно отдельного упоминания. Наследование в языках со статической системой типов является самым строгим и жестким видом отношений в исходном коде, следовательно, его следует использовать с большой осторожностью. Наследование в языках с динамической системой типов влечет меньшее количество проблем, но все еще остается зависимостью, поэтому дополнительная предосторожность никогда не помешает.
   + *Не переопределяйте конкретные функции.* Конкретные функции часто требуют зависимостей в исходном коде. Переопределяя такие функции, вы не устраняете эти зависимости — фактически вы наследуете их. Для управления подобными зависимостями нужно сделать функцию абстрактной и создать несколько ее реализаций.
   + *Никогда не ссылайтесь на имена конкретных и изменчивых сущностей.* В действительности это всего лишь перефразированная форма самого
принципа.
