# SOLID-принципы
Это принципы проектирования архитекруры систем

- [Single responsibility](#single)
- [Open-closed](#open)
- [Liskov substitution](#liskov)
- [Interface segregation](#interface)
- [Dependency inversion](#dependency)

### <a name="single"></a> Single responsibility — принцип единственной ответственности
+ **Модуль должен отвечать за одного и только за одного актора.**
+ Принцип декларирует, что каждый объект должен иметь *одну обязанность* и эта обязанность должна быть *полностью инкапсулирована в класс*, а все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.
Следование принципу заключается обычно в декомпозиции сложных классов, которые делают сразу много вещей, на простые, отвественность которых очень специализирована. Но также и объединении в отдельный класс однотипной функциональности, которая может оказаться распределённой по многим классам, может рассматриваться как следование этому принципу.
SRP требует сознательного и осмысленного применения. Чрезмерная декомпозиция может оказаться и вредной, если она приводит к большей сложности или усложняет сопровождение.

### <a name="open"></a> Open-closed — принцип открытости / закрытости
+ **Программные сущности должны быть открыты для расширения и закрыты для изменения.**
+ Если одно изменение в программе влечет за собой каскад изменений в зависимых модулях, то в программе проявляются нежелательные признаки «плохого» дизайна.
Программа становится хрупкой, негибкой, непредсказуемой и непереиспользуемой. Принцип открытости-закрытости решает эти проблемы очень прямолинейным путем. **Он говорит, что необходимо проектировать модули, которые никогда не меняются.** Когда требования меняются, нужно расширять поведение таких модулей путем добавления нового кода, а не изменением старого, уже работающего кода.
+ Принцип открытости/закрытости — одна из движущих сил в архитектуре систем. Его цель — сделать систему легко расширяемой и обезопасить ее от влияния изменений. Эта цель достигается делением системы на компоненты и упорядочением их зависимостей в иерархию, защищающую компоненты уровнем выше от изменений в компонентах уровнем ниже.

### <a name="liskov"></a> Liskov substitution — принцип подстановки Барбары Лисков
+ **Наследующий класс должен дополнять, а не замещать поведение базового класса.**
+ *Если для каждого объекта o1 типа S существует такой объект o2 типа T, что для всех программ P, определенных в терминах T, поведение P не изменяется при подстановке o1 вместо o2, то S является подтипом T1*
+ Если у нас есть класс A (не виртуальный, а вполне реально используемый в коде) и отнаследованный от него класс B, то если мы заменим все использования класса A на B, ничего не должно измениться в работе программы. Ведь класс B всего лишь расширяет функционал класса A.

### <a name="interface"></a> Interface segregation — принцип разделения интерфейса


### <a name="dependency"></a> Dependency inversion — принцип инверсии зависимостей
