# DJANGO:
[примеры кода можно посмотреть здесь](https://github.com/Chudopal/Django_learning)

[докуметация Django](https://docs.djangoproject.com/en/3.0/)

**Django - это фреймворк для backend разработки, написанный на python.**
+ ## [Настройка виртуальной среды](#settings_of_env)
+ ## [Основные термины](#basics_termins)
+ ## [Основные команды Django](#basic_commands_django)
+ ## [Создание проекта и приложения](#make_model_and_app)
+ ## [Модели Django](#models_of_django)
  + ### [Создание моделей](#create_model)
  + ### [Немного про внешний ключ](#forignkey)
  + ### [Добавление моделей в abmin.py](#add_in_admin)
  + ### [Настройка отображения моделей](#display_of_models)
+ ## [Работа с оболочкой](#query_set)
+ ## [Обработчики Django](#handl)
  + ### [views.py](#look_of_site)
  + ### [Добавление шаблонов URL](#urltemp)
+ ## [Djando-forms](#django_forms)
+ ## [Django шаблоны](#templates)
  + ### [Переменные](#var)
  + ### [Фильтры](#filters)
  + ### [Теги](#tags)

## <a name="settings_of_env"></a> Настройка виртуальной среды
+ Для того, чтобы начать Django-проект желательно сделать виртуальную среду и установить в ней Django.
+ Для того, чтобы уcтановить виртуальную среду необходимо создать папку, в которой в консоли прописать: `python3 -m venv name_of_env` 
+ Далее для работы необходимо активировать виртуальную среду:
`source name_of_env/bin/activate`
+ На то, что среда активированна укажет ее название перед именем пользователя в скобках в терминале:
`(name_of_env) alexandr@alexandr-VivoBook-15-ASUS-Laptop-X570UD:~/git_hub/django/blogsite$`
+ Чтобы деактивировать среду, надо просто прописать в терминале:
`deactivate`
+ Перед тем как установить Django желательно обновить pip;
`python3 -m pip install --upgrade pip`
+ Для установки Django версии 2.0.5 необходимо прописать в терминале:
`pip install Django==2.0.5`
+ Для того, чтобы посмотреть какие пакеты с их версиями установленны в среде необходимо выполнить команду:
`pip freeze`

## <a name="basics_termins"></a> Основные термины
В Django *проект* – это код, созданный с использoванием Django и содержащий некоторые настройки. 

*Приложение* – это набор модулей, описывающих модели, обработчики запросов, шаблоны и конфигурации URL’ов. Приложение взаимодействует с фреймворком, предоставляя некоторую функциональность, и может быть многократно использовано в других проектах. Мы можем сопоставить проект с сайтом, который состоит из
нескольких приложений (блога, раздела вопросов, форума), каждое из которых
может быть использовано и в других проектах.

*Миграции* - это что-то вроде системы контроля версий для базы данных. Они позволяют команде программистов изменять структуру БД, в то же время оставаясь в курсе изменений других участников. Миграции обычно идут рука об руку с конструктором таблиц для более простого обращения с архитектурой вашего приложения.

*QuerySet* — список объектов заданной модели. QuerySet позволяет читать данные из базы данных, фильтровать и изменять их порядок.

## <a name="basic_commands_django"></a> Основные команды Django
Команды просто писать в терминале:

+ **`source name_of_env/bin/activate`** - активация виртуальной среды.
+ **`deactivate`** - деактивация виртуальной среды.
+ **`django-admin startproject mysite`** - создание проекта  mysite.
+ **`python manage.py runserver`** - запуск сервера. 
+ **`python manage.py startapp blog`** - создание приложения blog.
+ **`python manage.py makemigrations blog`** - инициализирующая миграция, ее нужно делать всякий раз после изменения models.py.
+ **`python manage.py sqlmigrate blog 0001`** - выводит SQL код миграции 0001 в консоль.
+ **`python manage.py migrate`** - синхронизация базы данных. Применение миграции для всех приложений, указанных в INSTALLED_APPS, файла setting.py.
+ **`python manage.py createsuperuser`** - создание сайта администрирования. На нем можно управлять всеми моделями, которые в нем определены.
+ **`python manage.py shell`** - открыть оболочку.

## <a name="make_model_and_app">  Создание проекта и приложения
**`django-admin startproject mysite`** - создание проекта  mysite.
После создания проекта в директории появится папка mysite, в которой будет следующее содержимое:
```
mysite/ 
    manage.py           - утилита командной строки для управления проектом.
    mysite/             - сама папка проекта.
        _init__.py      - говорит Python о том, что mysite является Python-пакетом.
        settings.py     - конфигурация проекта.
        urls.py         - здесь будут содержаться шаблоны адресов.
        wsgi.py         - конфигурация для запуска проекта как WSGI-приложения.

```
Далее можно посмотреть, успешно ли создался проект, для этого необходмо его запустить:
**`python manage.py runserver`** - запуск сервера, по умолчанию он доступен по адресу `127.0.0.1:8000` или `localhost:8000`, чтобы изменить адрес или файл кофигурации нужно в консоле запустить сервер следующим образом: `python manage.py runserver 127.0.0.1:8001 --settings=mysite.settings`

**`python manage.py startapp blog`** - создание приложения blog. Приложения - это блоки проекта.
```
blog/
    __init__.py
    admin.py            - регистрируем модели для добавления их в систему администрирования Django.
    apps.py             - файл, содержащий основную конфигурацию приложения blog.
    migrations/         - папка, содержащая миграции базы данных приложения.
        __init__.py
    models.py           - модели данных приложения.
    tests.py            - файл для тестов приложения.
    views.py            - вся логика хранится здесь.
```
Чтобы приложение blog было видно Django, необходимо добавить 
*blog.apps.BlogConfig* в настройку INSTALLED_APPS в файле settings.py. 
Класс BlogConfig – это конфигурация приложения.

## <a name="models_of_django"></a> Модели Django
**Модели** отображают информацию о данных, с которыми вы работаете. Они содержат поля и поведение ваших данных. Обычно одна модель представляет одну таблицу в базе данных.

Основы:
+ Каждая модель это класс унаследованный от *django.db.models.Model*.
+ Атрибут модели представляет поле в базе данных.
+ Django предоставляет автоматически созданное API для доступа к данным.
### <a name="create_model"></a> Создание моделей 
Модели описываются в файле models.py:
```python
from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User

# Create your models here.

class Post(models.Model):
    """Класс для формирования модели поста в базе данных.
    Если вдруг происходит изменение здесь,
    необходимо пересобрать базу данных"""

    STATUS_CHOICES = ( 
        ('draft','Draft'),  
        ('published','Published'),
    )
    title = models.CharField(max_length=250) #заголовок статьи, базе данных пребразуется в обычный VARCHAR
    slug = models.SlugField(max_length=250, unique_for_date='publish') #Поле для формаирования URL-ов. unique_for_date - для формирования уникальных имен
    author = models.ForeignKey(User, on_delete=models.CASCADE, #внешний ключ,определеят отношение "один ко многим".  
                               related_name='blog_posts')#on_delete -определяет поведение при удалиении пользователя. CASCADE - удалять все посты пользоватля.
                                                         #related_name - имя обратной связи от User к Post. Так можно найти вязанные посты автора
    body = models.TextField()#основное содержание статьи.
    publish = models.DateTimeField(default=timezone.now) #поле даты, которое сохраняет дату публикации. datetime.now - возвращает текущую дату.
    created = models.DateTimeField(auto_now_add=True)#поле даты. указывает, когда статья была создана. auto_now_add - авто сохранение даты при создании объекта
    updated = models.DateTimeField(auto_now=True)#дата и время, когда статья была отредактирована. auto_now - дата будет сохраняться автоматически при создании объекта
    status = models.CharField(max_length=10,choices=STATUS_CHOICES,default='draft')#отображает статус статьи.  STATUS_CHOICES - отсюда будут браться варианты
    class Meta:
        """Метаданные
        Здесь мы указали, что статьи должны
        сортироваться по дате публикации"""

        ordering = ('-publish',)#"-" - означает что сортировка должна происходить по убыванию
        def __str__(self):
            return self.title
```
Каждое поле определено как атрибут класса, и каждый атрибут соответствует полю таблицы в базе данных.
После изменения модели необходимо прописать в терминале:
+ `python manage.py makemigrations name_of_app`
+ `python manage.py migrate`

### <a name="forignkey"></a> Немного про внешний ключ

Термин «внешний ключ» (foreign key) происходит из теории баз данных; внешний ключ содержит ссылку на другую запись в базе данных. Таким образом можно сделать иерархическую модель наподобии "Жанр - фильм" или "Топик - текст". В Django это можно релизовать вледующим образом:
```python
from django.db import models

# Create your models here.

class Topic(models.Model):
    """Тема, которую изучает пользователь"""
    text = models.CharField(max_length=200)
    date_added = models.DateTimeField(auto_now_add=True)
    def __str__(self):
        """Возвращает строковое представление модели."""
        return self.text


class Entry(models.Model):
    """Информация, изученная пользователем по теме"""
    topic = models.ForeignKey(Topic, on_delete=models.CASCADE) #ВНЕШНИЙ КЛЮЧ
    text = models.TextField()
    date_added = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        verbose_name_plural = 'entries'
    
    def __str__(self):
        """Возвращает строковое представление модели."""
        return self.text[:50] + "..."
``` 
В данном случае реализованна модель "многие-к-одному", так как множество различные записей(Entry) может принадлежать одной теме(Topic).

### <a name="add_in_admin"></a> Добавление моделей в admin.py
**`python manage.py createsuperuser`** - создание сайта администрирования. На нем можно управлять всеми моделями, которые в нем определены.
Чтобы приложение показывало свою модель на странице администрирования необходимо изменить
файл admin.py этого приложения таким образом:
```python
from django.contrib import admin
from .models import Post

admin.site.register(Post)
```
Где *Post* - это модель из приложения. Теперь на `localhost:8000/admin` можно добавить или удалить экземляры моделей данного приложения.

### <a name="display_of_models"></a> Настройка отображения моделей
Можно настривать отображение моделей в /admin, 
```python
from django.contrib import admin
from .models import Post

@admin.register(Post) #декоратор, то же самое что и admin.site.register(Post)
class PostAdmin(admin.ModelAdmin):
    list_display = ('title', 'slug', 'author', 'publish','status') #столбцы таблицы
```
Так мы говорим Django, что наша модель зарегистрирована на сайте администрирования с помощью пользовательского класса, наследника `ModelAdmin`.

## <a name="query_set"></a> Работа с оболочкой
Django ORM основана на объектах запросов *QuerySet*. QuerySet – это коллекция объектов, полученных из базы данных. К ней могут быть применены фильтрация и сортировка.
+ Чтобы добавить объект в БД, необходимо открыть терминал и прописать `python manage.py shell`,затем прописать следующие строки:
    ```python
    >>> from django.contrib.auth.models import User
    >>> from blog.models import Post
    >>> user = User.objects.get(username='admin') #ищем пользователя с таким именем
    >>> post = Post(title='Another post', slug='another-post',
    body='Post body.', author=user)
    >>>post.save()#сохраняем объект в базу данных
    ``` 
+ Чтобы получить доступ ко все объектам БД необходимо прописать `>>> all_posts = Post.objects.all()`
+ Методы сортировки:
  + *filter()*:
    `Post.objects.filter(publish__year=2017)` - сортировка записей из 2017 года.
    **Условия фильтрации строятся с использованием двойного подчеркивания например publish__year.**
  + *exclude()*:
    фильтр имключения, т е мы исключаем все записи, которые подходят под него: `Post.objects.filter(publish__year=2017).exclude(title__startswith='Why')`
  + *order_by()*:
    для сортировки по полям: `Post.objects.order_by('title')` - алфавитном порядке, `Post.objects.order_by('-title')` - в обратном порядке.
+ Чтобы удалить объект:
    *delete()*: 
    ```python
    post = Post.objects.get(id=1)
    post.delete()
    ```
    Бывают случаи(очень часто), когда необходим доступ по внешнему ключу:
    ```python
    >>>t = Topic.objects.get(id=1)
    >>>t.entry_set.all()
    ```
    В данном случае в классе *Entry* есть поле `topic = models.ForeignKey(Topic, on_delete=models.CASCADE)`, т.е. внешний ключ к классу Topic.
    Чтобы получить данные через отношение внешнего ключа, необходимо использовать имя связанной модели, записанное в нижнем регистре, за которым следует символ
    подчеркивания и слово set.

## <a name="handl"></a> Обработчики Django
Обработчик Django – это простая Python-функция, которая получает веб-запрос и возвращает веб-ответ. Вся логика, формирующая желаемый ответ, описывается внутри этой функции. Каждый обработчик генерирует шаблон, используя переменные контекста, и возвращает HTTP-ответ со сформированной HTML-страницей.

### <a name="look_of_site"></a> views.py
Функция представления или обработчики получает информацию из запроса, подготавливает данные, необходимые для построения страницы, и возвращает данные браузеру — часто
с использованием шаблона, определяющего внешний вид страницы.
Обработчики необходимо описывать в `views.py`:
```python
def post_list(request):
    """Обработчик для отображения списка статей

    request - обязателен для всех обработчиков
    В этой функции мы запрашиваем 
    из БД все опубликованные статьи с помощью
    менеджера published
    """
    posts = Post.published.all()#запрос из бд
    return render(              #формирует шаблон со списка статей
        request,                #принимает объект запроса request,  
        'blog/post/list.html',  #путь к шаблону
        {'posts':posts}         #и переменные контекста для этого шаблона.     
    )

```
Во `views.py` мы описываем логику реакции на запрос, а frontend формируется в папке template приложения. Мы используем функцию render() для формирования шаблона. Она принимает объект запроса **request**, **путь к шаблону** и **переменные контекста** для этого шаблона. В ответ вернется объект HttpResponse со сформированным текстом (обычно это HTML-код). Функция render() использует переданный контекст при формировании шаблона, поэтому любая
переменная контекста будет доступна в шаблоне. *Процессоры контекста – это вызываемые функции, которые добавляют в контекст переменные.*

### <a name="urltemp"></a> Добавление шаблонов URL
Обычно процесс создания веб-страниц в Django состоит из трех стадий: опреде ления URL, написания представлений и написания шаблонов. Сначала следует определить схемы (patterns) URL. Схема URL описывает структуру URL-адреса и сообщает Django, на какие компоненты следует обращать внимание при сопоставлении запроса браузера с URL-адресом на сайте, чтобы выбрать возвращаемую страницу.
Затем каждый URL-адрес связывается с конкретным представлением — функция представления читает и обрабатывает данные, необходимые странице. Функция
представления часто вызывает шаблон, который строит страницу, подходящую для передачи браузеру.
Шаблоны URL’ов позволяют сопоставить адреса с обработчиками. Шаблон представляет собой комбинацию из строки, описывающей адрес, обработчика и необязательного названия, которое даст возможность обращаться к этому шаблону на всех уровнях проекта. Django проходит по порядку по всем шаблонам,пока не найдет первый подходящий, т. е. совпадающий с URL’ом запроса. Затем Django сможет импортировать соответствующий обработчик и выполнить его, передав внутрь объект запроса HttpRequest и ключевые слова или позиционные аргументы.
Для этого необходимо в папке приложени создать файл `urls.py`(Любое значение, определенное в шаблоне как `<parameter>`, возвраща-
ется в виде строки):
```python
    from django.urls import path
    from . import views
    app_name = 'blog'#ОПРЕДЕЛЕНИЕ ПРОСТРАНСТВА ИМЕН

    urlpatterns = [
    # post views
    path('', views.post_list, name='post_list'),#вызов обработчика
    path('<int:year>/<int:month>/<int:day>/<slug:post>/',
    views.post_detail, name='post_detail'), 
    ]
```
Так же необходимо отредактировать `urls.py`, который находится в радительском каталоге:
```python
    from django.urls import path, include
    from django.contrib import admin

    urlpatterns = [
    path('admin/', admin.site.urls),
    path('blog/', include('blog.urls', namespace='blog')),#именно здесь мы добавили юрлы приложения
    ]
```
**`include - подключает конфигурацию приложения.`**

В Django есть соглашение о том, что метод модели get_absolute_url() должен возвращать канонический URL объекта:
```python
    from django.urls import reverse
    class Post(models.Model):
    # ...
    def get_absolute_url(self):
        return reverse('blog:post_detail', args=[self.publish.year,
        self.publish.month, self.publish.day, self.slug])
```


## <a name="django_forms"></a> Django-forms

Django имеет встроенную *подсистему* форм, которая позволяет легко управлять ими.
Эта подсистема дает возможность описать поля формы, указать, как они будут
отображаться и как будет проверяться корректность данных.

В  Django встроеены два базовых класса форм:
+ **Form** - позволяет создавать стандартные формы.
+ **ModelForm** - дает возможность создавать формы по объектам моделей.

Формы могут быть описаны в любом месте вашего проекта, но есть общее соглашение,
чтобы они находились в файле **forms.py** каждого приложения:
```python
from django import forms

class EmailPostForm(forms.Form):
    """Класс для формы заполнения эмейла"""
    name = forms.CharField(max_length=25)
    email = forms.EmailField()
    to = forms.EmailField()
    comments = forms.CharField(required=False,widget=forms.Textarea)
```

Далее необходимо изменить файл **views.py**, чтобы обрабатывал данную форму:
```python
def post_share(request, post_id):
    # Получение статьи по идентификатору.
    post = get_object_or_404(Post, id=post_id,status='published')
    if request.method == 'POST':
        # Форма была отправлена на сохранение.
        form = EmailPostForm(request.POST)
    if form.is_valid():
        # Все поля формы прошли валидацию.
        cd = form.cleaned_data
        # ... Отправка электронной почты.
    else:
        form = EmailPostForm()
        return render(request, 'blog/post/share.html',
            {'post': post, 'form': form})

```

## <a name="templates"></a>Шаблоны
Шаблоны Django - это просто текстовый файл или строка Python, которые следуют языку шаблонов Django
Синтаксис языка шаблонов Django спользует 4 конструккции:
+ Переменные: `{{variable}}`
+ Фильтры:`{{variable|filter}}`
+ Теги:`{%...%}`
+ Комментарии:{#comment#}

### <a name="var"></a>Переменные
Переменные выглядят таким образом: {{ variable }}. Когда шаблон встречает переменую, он вычисляет ее и заменяет результатом. Названия переменных могут состоять из букв, цифр и нижнего подчеркивания("_"). Если использовать точку, то можно получить доступ к:
+ Ключ словаря
+ Атрибут
+ Вызов метода
+ Индекс списка
Если переменная не найдена, шаблон вставит значение из настройки TEMPLATE_STRING_IF_INVALID, которая равна '' (пустой строке) по-умолчанию.

Передача переменных производится при помощи передачи словаря с переменными в функцию **render()**, он присвивается свойству **context**:
+ views.py:
    ```python
    from django.shortcuts import render

    def index(request):
        data = {"header": "Hello Django",   "message": "Welcome to Python"}
        return render(request, "index.html",    context=data)
    ```
+ index.html:
    ```html
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8" />
        <title>Hello Django</title>
    </head>
    <body>
        <h2>{{ header }}</h2>
        <p>{{ message }}</p>
    </body>
    </html>
    ```
### <a name="filters"></a>Фильтры
Вы можете изменить значение переменной используя фильтры.

Фильтры выглядят таким образом: `{{ name|lower }}`. Это выведет значение переменной `{{ name }}` после применения фильтра lower к нему, который преобразует значение в нижний регистр. Используйте символ (|) для применения фильтра.
Можно использовать “цепочку” фильтров. Вывод одного фильтра используется для другого. `{{ text|escape|linebreaks }}` обычно применяется для экранирования текста, и замены переноса строки тегами `<p>`.
Некоторые фильтры принимают аргументы. Аргумент фильтра выглядит таким образом: `{{ bio|truncatewords:30 }}`. Этот код отобразит первые 30 слов переменной bio.
Аргументы фильтров, которые содержат пробелы, должны быть заключены в кавычки. Например, что бы объединить список пробелом и запятой, используйте `{{ list|join:", " }}`.
### <a name="tags"></a>Теги
Теги выглядят таким образом: **`{% tag %}`**. Теги сложнее чем переменные: одни создают текст для вывода, влияют на выполнение используя условия и циклы, другие загружают дополнительную информацию в шаблоны что бы использовать ее далее через переменные.
Некоторые теги требуют открывающий и закрывающий теги (например, `{% tag %} ... содержимое тега ... {% endtag %}`).
